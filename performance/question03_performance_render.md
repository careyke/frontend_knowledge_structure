# 性能优化—渲染层面

在浏览器渲染html页面的过程中，会经历下面的流程：

1. 解析html文件生成DOM Tree
2. 解析css文件生成CSSOM Tree
3. 遇到js文件的时候，会阻塞DOM的解析，等待js文件执行完成之后再继续解析
4. DOM Tree和CSSOM Tree合成Render Tree，然后进行排列和绘制

所以在渲染层面的优化可以大致分成以下一个方向：

1. html层面的优化
2. css层面的优化
3. js层面的优化

## 1. html层面的优化-服务端渲染

现在的前端应用中，基本都是使用三大框架来完成的。以React为例，在React应用中，html页面的节点的很少的，页面中的节点基本都是通过React动态插入的，所以**页面的首屏展示需要依赖js文件的加载和执行**。

当应用很复杂的时候，js文件是比较大的，所以会导致较长时间的白屏，所以有了另一种渲染方式—服务端渲染的产生。

**服务端渲染指的是在服务端就将页面的首屏节点插入到html页面中，这样浏览器在获取到html页面之后就可以直接渲染出来首屏的内容，而不需要先去执行一次js脚本才能过去首屏。**

服务端渲染还有一个重要的优势：**网站的SEO**

搜索引擎在搜索的时候，只会查找html中现有的内容，而不会去执行js脚本。而现在的前端应用（CSP）中，html文件中的信息是非常少的，所以需要使用服务端渲染来优化这个问题。

服务端渲染的优势：

1. 缩短网页的白屏时间
2. 优化网站的SEO

## 2. css层面的优化

在前面的文章中分析过，构建CSSOM树有以下的特点：

1. 构建CSSOM树的过程和DOM Tree的构建是并行的
2. CSSOM Tree的构建会阻塞Render Tree的合成
3. CSSOM Tree的构建会阻塞后面js文件的执行

所以针对css文件的第一个优化就是：**将css文件尽可能放在html的前面引入，尽早开始CSSOM的构建，减少阻塞的时间**

在将DOM Tree和CSSOM Tree合成Render Tree的过程中，需要将css中的样式规则匹配到对应的节点。

事实上，**CSS选择器的匹配过程是从右到左来匹配的**。匹配的过程中，涉及到DOM节点的遍历，这是一个比较耗时的过程，而且不同的选择器造成的性能差别是比较大的。所以对于css选择器的书写，需要遵循一定的规则，好的书写习惯可以带来不小的性能提升。

1. 避免使用通配符
2. 尽量少使用标签选择器
3. 提倡使用id选择器和类型选择器
4. 减少选择器嵌套的层级

当页面中存在比较复杂的动画的时候，可以考虑将动画元素提升到一个单独的复合图层中，也就是开启**硬件加速**，可以使动画元素的重排和重绘不影响其他的元素。

**css层面的优化方案**：

1. 将css文件尽可能的放在html文件的前面引入
2. 优化css中样式规则的选择器
3. 对于动画元素开启硬件加速

## 3. js层面的优化

### 3.1 js文件的引入顺序

之前的文章中分析过，浏览器在渲染的过程中，不是等到整个Render Tree都构建完成才开始渲染的。而是在解析到js文件的时候，如果当前这个js文件没有下载完成或者js的执行被前面的CSSOM阻塞，这时浏览器会执行一次UI Render，将此时已经解析好的DOM渲染出来。

所以需要将 `script` 标签放在body最下面，这样可以**在首屏的渲染中出现更多的节点**。还有一个重要的原因是，**js代码中可能有获取某个dom节点的操作，如果将js文件放在前面，当代码执行的时候，对应的DOM节点可能还没有加载出来。**

### 3.2 异步引入js

在script的标签中，有两个属性`async/defer`可以并行下载js文件，可以使用这种方式，避免js文件的下载过程阻塞DOM的解析。

- 当js文件之间没有相互依赖的时候，可以使用async

- 当js文件之间有相互依赖关系的时候，可以使用defer

### 3.3 减少操作DOM的次数

#### 3.3.1 为什么操作DOM是一个耗时的操作

因为js引擎和DOM所在的渲染引擎是两个不同的地方，所以通过js代码不管是修改和访问DOM对象的时候，都需要跨界交流。这个交流的时间是不可以忽略的时间。

如果js中存在多个dom的操作，消耗的时间是很长的。所以需要尽量减少DOM的操作次数

#### 3.3.2 重排和重绘

重排：当页面中某个元素的尺寸发生变化的时候，导致其他的元素也会发生位置或者尺寸的修改，这是浏览器就需要重新计算每个元素的位置，然后进行绘制出来。

重绘：当页面中某个元素的背景颜色或者字体颜色改变的时候，这时元素的尺寸和位置并没有发生改变，所以只需要进行重新绘制即可。

所以说：**重排肯定会导致重绘，重绘不知道有重排。**

重排相对于重绘来说影响范围更大，也更耗时。

### 总结

js层面的优化：

1. 在body的最下面引入js文件
2. 异步引入js文件
3. 尽量减少DOM的操作，减少重排和重绘
