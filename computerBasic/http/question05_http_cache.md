# 谈谈http缓存

在实际的项目中，往往涉及到一些静态资源的加载，比如js文件。如果每次请求都去服务器中重新加载的话，无疑是低效的，因为在大多数情况下，这些静态资源基本是保持不变的。

于是就出现了http缓存的方案，http缓存分成两种方式：

1. 强缓存
2. 协商缓存

**http缓存属于客户端缓存，缓存的内容是存放在客户端的**



## 1. Cache-Control字段

在请求头和响应头中都有这个字段，用来定义当前资源的缓存配置项。

Cache-Control字段常用的取值

1. public：表明资源可以被任何对象缓存，包括中间的代理服务器
2. private：表示资源是私有的，不能被中间层的代理服务器缓存
3. no-cache：表示浏览器端不做缓存检查，强制让服务端来做缓存检查，如果使用缓存则返回304
4. no-store：表示该资源无法缓存
5. max-age：表示缓存的最大存储时间，它表示的是一个相对于请求时间的时间长度。和Expires有所不同



## 2. 强缓存

强缓存指的是在请求某个资源的时候，**由客户端来判断是否使用缓存**，不需要经过服务端

- 如果缓存命中，则直接使用缓存服务器中的缓存，**不需要再访问服务器判断**
- 如果缓存没有命中，则需要请求服务器获取资源

强缓存使用的头部字段

1. Expires：**表示的是服务器返回的当前资源的过期时间**，如果在没有过期之前再次访问的话，会直接从缓存服务器中获取。
   - 缺点：**因为Expires返回的是服务端的时间，和客户端的时间往往存在一定的误差**，也就会导致缓存的命中存在误差
2. Cache-Control：这个字段是用来替换Expires字段的，可以使用max-age来设置缓存存在的最大时间，是一个**相对时间**。

> **Cache-Control和Expires是可以同时存在的，Cache-Control的优先级更高。**



## 3. 协商缓存

协商缓存指的是在请求资源的时候，需要经过服务端，**由服务器来判断是否使用缓存**

- 如果缓存命中，则返回304，由浏览器去缓存中获取对应的资源
- 如果没有命中缓存，则去数据库中重新获取，然后在响应报文中返回

协商缓存使用的头部字段：

1. **If-Modified-Since 和 Last-Modified**：if-Modified-Since表示的是客户端保存的当前资源的最后修改时间，第二次请求的时候会放在请求头中带过去。服务端会将这个时间和服务端保留的最后修改时间对比，如果是一致的，就返回304，需要从缓存中获取；否则就需要从数据库中获取，响应头中通过Last-Modified来更新最后一次的修改时间
   - 缺点：有可能一个资源被修改了，但是实际上的内容是没有修改的，但是这时无法命中协商缓存
   - 优点：相对于ETag方案来说，获取修改时间相对更快一些，消耗更小一点
2. **If-None-Match 和 ETag**
   - ETag指的是当前资源通过某种算法生成的唯一标识，如果内容没有改变，则生成的标识也不会变化
   - If-None-Match是客户端缓存中资源的标识，在第二次请求的是，会将这个标识放在请求头中带过去，服务端会将此标识和内部资源的实际标识作对比，如果一致，则命中协商缓存，返回304；否则就需要从服务端返回最新的资源，并在响应头中通过ETag返回最新的标识
   - 优点：可以准确的判断当前的资源是否有变化
   - **缺点**：相对于修改时间的方案来说，获取ETag的过程比较耗时



**两种协商缓存方案可以同时存在，但是第二种也就是Etag方案的优先级更高**



## 4. 强缓存 VS 协商缓存

**强缓存和协商缓存是可以同时存在的，但是强缓存的优先级更高。**

缓存方案优先级（从高到底）：

1. 强缓存 — `cache-control: max-age=xxx`
2. 强缓存 — expires
3. 协商缓存 — Etag
4. 协商缓存 — last-modified



## 参考文章

1. [HTTP----HTTP缓存机制](https://juejin.im/post/5a1d4e546fb9a0450f21af23)
2. [面试精选之http缓存](https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-2)

