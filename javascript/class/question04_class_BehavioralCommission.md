# 类 VS 行为委托
js为使用面向对象的设计模式，所以内部模拟了类的实现。从而也就产生了new操作符和构造函数的概念。但是本质上是通过原型链来实现的。

**使用类是为了将一些通用的属性和方法封装起来，然后使每一个实例都可以使用这些属性和方法。本质上就是对象与对象之间的关联。一个对象可以使用另一个对象中的方法。**

那为什么不直接通过原型将两个对象关联起来，而要去多封装一个类的概念呢？理论上显然是可行的，js将这种设计模式叫**行为委托**。

## 行为委托
**行为委托指的是讲一个对象和另一个对象使用原型链关联起来，然后就可以将自身委托给其他对象，通过其他对象的方法来生成自身的属性。**

对象之间的关系是兄弟关系，不需要继承和多态的概念。使用起来更加直接，结构也更加简洁

### 类实现
在类的设计模式中，提倡的是将所有的方法都定义在父类中，然后在子类中进行重写（多态）。
```js
function Foo(who) { 
  this.me = who;
}
Foo.prototype.identify = function() {
  return "I am " + this.me; 
};
function Bar(who) { 
  Foo.call( this, who );
}
Bar.prototype = Object.create( Foo.prototype );
Bar.prototype.speak = function() {
  alert( "Hello, " + this.identify() + "." );
};
var b1 = new Bar( "b1" );
var b2 = new Bar( "b2" );
b1.speak();
b2.speak();
```  

### 行为委托实现
行为委托提倡的是之间将对象关联起来，使用其他对象中的方法
```js
Foo = {
  init: function(who) {
    this.me = who; 
  },
  identify: function() {
    return "I am " + this.me;
  } 
};
Bar = Object.create( Foo );  //创建关联关系
Bar.speak = function() {
  alert( "Hello, " + this.identify() + "." );
};
var b1 = Object.create( Bar ); 
b1.init( "b1" );
var b2 = Object.create( Bar );
b2.init( "b2" );
b1.speak(); 
b2.speak();

```  

### 两者之间的对比
1. 两种设计模式想要达到的目的都是**为了通过原型链将对象关联起来，可以是一个对象去使用另一个对象中的方法。**
  - 类的设计模式，**使用了构造函数，new以及原型对象的概念，将整个对象之间的关联关系弄得非常复杂，容易弄错。**将原本简单的东西复杂化了
  - 行为委托的设计模式，开门见山，直奔主题。**需要使用哪个对象中的方法就直接将自身和它关联起来，然后将自身委托过去调用它的方法即可**。
2. 类的模式中，将**对象的创建和初始化过程放在一起使用new操作符完成了**，但是其实是两个过程，在某些场景中分开其实是很有意义的。**行为委托的方式是分开的。**


## 总结
不管是类还是行为委托，**本质上都是将对象与对象通过[[prototype]]属性关联起来**。
- 类的模式中，对象之间是父子关系，提倡在子元素中重写父类中的方法。**对象之间的关联关系很隐蔽，需要使用构造函数，new操作符和原型对象来完成。是一种间接关联**
- 行为委托的模式，对象之间是兄弟关系，**它倡导的是直接创建和关联对象，不需要抽象成类，通过其他的方式来间接关联对象。是一种直接关联**。而且代码更加间接，结构更加清楚。








