## JS中的位运算
位运算就是对数字的二进制位操作的运算。

### 1.原码、反码和补码
数字的二进制数存储分成**符号位和数值位**。正数的符号位是0，负数的符号位是1.

- 原码：正数是其二进制本身；负数是符号位为1，数值部分取X绝对值的二进制
- 反码：正数的反码和原码相同；负数是符号位为1，其它位是原码取反
- 补码：正数的补码和原码，反码相同；负数是符号位为1，其它位是原码取反，未位加1

**在位运算中，正数使用的是原码进行计算；负数使用的是补码进行计算**。（应该理解为都是使用补码进行计算，碰巧整数的补码就是本身）

### 2.位运算符号
js中number类型的数值占4个字节，也就是32位二进制位。**位运算会将操作数当成32位的bit序列进行操作，多余的位数会直接截掉。**

#### 2.1 按位与（&）
对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。
```js
a = 00000001 //1
b = 00000010 //2

a & b //0
也就是：
1 & 2 //0
```

#### 2.2 按位或（|）
对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。
```js
a = 00000001 //1
b = 00000010 //2

a | b = 00000011
也就是：
1 | 2 //3
```

#### 2.3 按位异或（^）
对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。
```js
a = 00000001 //1
b = 00000011 //3

a ^ b = 00000010
也就是：
1 ^ 3 //2
```

#### 2.4 按位非（~）
反转操作数的比特位，即 0 变成 1，1 变成 0。
```js
a = 00000001 //1

~a = 1111...1110 //负数的补码
所以：
~a  //-2
```

#### 2.5 左移(<<)
将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。
```js
var a = -2 //1000...0010
a << 1 

反码：1111...1101
补码：1111...1110
移位之后：1111...1100
反码：1111...1011
原码：1000...0100 //-4
a << 1 //-4

a >> 1
移位之后：1111...1111
反码：1111...1110
原码：1000...0001 //-1
```
这个可以看出，对于**有符号的移位运算（<<, >>）**
1. 对于<<，往左移的时候，右边空白部分补0
2. 对于>>，**往右移的时候，左边空白部分填补和符号位一样的数字**。

#### 2.6 右移(>>)
将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。


#### 2.7 无符号右移（>>>）
将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并**使用 0 在左侧填充，无论符号位是什么**。

```js
var a = -2 //1000...0010
a >>> 1 

反码：1111...1101
补码：1111...1110
移位之后：0111...1111
这时符号位是0，是正数。正数的原码，反码和补码都一样
所以：
a >>> 1 //2147483647
```

### 3.位运算的使用
1. [JavaScript 中的位运算和权限设计](https://juejin.im/post/5dc36f39e51d4529ed292910) —— 很经典的使用场景











