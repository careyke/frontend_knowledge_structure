# 执行栈和执行上下文
js代码在经过编译之后，就会由js引擎开始执行。

js代码是执行在执行上下文这个环境中的，执行上下文中包含了很多执行需要访问的信息。

## 1.执行上下文的概念
**指向上下文是执行代码的环境的抽象概念，是在代码执行之前由js引擎动态创建的**。

但是并不是每执行一行代码之前就创建一个执行上下文，那样js引擎怕是要累死，而且频繁的创建和销毁会降低性能。

js中创建执行上下文是**以函数为单位创建**的，每一个函数执行之前都会创建一个执行上下文。

## 2 执行上下文的种类
虽然js中绝大多数的是函数的执行上下文，但是还是存在两种特殊的上下文：
1. **全局执行上下文**：任何不在函数内的代码，都是在全局执行上下文环境中执行的。全局上下文中会创建一个window(浏览器)对象，并且使this指定这个对象。**一个程序中只有一个全局执行上下文对象，而且会一直存在，直到窗口关闭。**
2. **eval函数执行上下文**：执行eval代码的时候也会动态生成一个执行上下文，类似于函数执行上下文，但是eval不推荐使用。
3. **function函数执行上下文**

## 3.执行栈
执行栈又称“调用栈”，**用来存储代码执行过程中创建的所有执行上下文对象**。是一种“先进后出（LIFO）”的数据结构。

之前说过，**基本类型的数据存储在栈内存中，这里的栈就是指的执行栈。执行上下文中的基本类型变量就是存储在执行栈中。对象类型的变量存储在堆内存中。**
![context01.jpg](./images/context01.jpg)
这里的queue指的是事件队列，会在event loop中讲解。

### 3.1 执行上下文在执行栈中如何存储
1. 当js引擎开始执行代码的时候，首先会创建一个全局执行上下文，并且压入执行栈中。
2. 每当执行一个函数调用之前，js引擎会为当前函数创建一个新的执行上下文，压入执行栈中。
3. js引擎会**执行位于栈顶的执行上下文所对应的函数或者全局代码，当这部分代码执行完之后，这个执行上下文从栈中弹出销毁**，然后继续执行下一个位于栈顶的执行上下文对应的代码，如此循环，直到代码执行完。

**注意**：
全局执行上下文并不会在程序执行完成之后销毁，而是在浏览器窗口关闭的时候销毁。

看图理解：
![context02.jpg](./images/context02.jpg)

```js
let a = 'Hello World!';

function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}

function second() {
  console.log('Inside second function');
}

first();
console.log('Inside Global Execution Context');
```



## 4.执行上下文的组成

代码经过编译之后，在代码正式执行之前，js引擎会先创建执行上下文。

**创建执行上下文的过程是动态的，并不是一开始就把所有代码的执行上下文都创建好。而是执行到哪个函数，就创建哪个函数的执行上下文**

**执行上下文的组成**：
1. **this值**的绑定
2. 创建**词法环境**组件
3. 创建**变量环境**组件

用代码类比为：
```js
ExecutionContext={
  ThisBound: <this value>,
  LexicalEnvironment: {...},
  VariableEnvironment: {...}
}
```


### 4.1 this绑定
**全局执行上下文中，this指向window（浏览器），在函数执行上下文中，this指向的值取决于函数如何被调用。**

this绑定是一个大的课题，这里暂时不展开讲，后面会有文章单独来讲。

**由于this是跟随的执行上下文生成的，而执行上下文也是代码执行之前动态生成的，所以也就可以证明this绑定也是动态绑定的。**

### 4.2 词法环境（和词法作用域很像）
词法环境是一个持有**标识符-变量映射关系**的结构。**标识符**指的是变量或者函数的名字，**变量**指的是基本类型数据或者实际对象的引用。

#### 4.2.1 词法环境的组成
1. 环境记录器：**存储变量和函数声明的实际位置**。
2. 外部环境的引用：指向**父级词法环境的指针（作用域链）**，说明它可以访问父级词法环境

词法环境有三种类型：
1. 全局词法环境：在全局执行上下文中，**没有外部环境引用的词法环境**，外部环境引用是null。环境记录器中存储的是全局对象window（浏览器）。
2. 函数词法环境：在函数执行上下文中，函数中定义的变量和内部函数声明都存储在词法记录器中，外部环境引用包括此函数的外部作用域。
3. 块词法环境：块级作用域对应的词法环境

> **词法环境在数据结构上是一个栈的结构，执行上下文中每个词法作用域都会对应一个词法环境。**



环境记录器也有两种类型：

1. 声明式环境记录器：存储变量、函数和参数。**函数执行上下文中，使用的就是声明式环境记录器**
2. 对象环境记录器：定义出现在**全局上下文**中的变量和函数的关系。**全局执行上下文中，使用的是对象环境记录器。**

**在函数执行上下文中，环境记录器还会存储一个传递给函数的`arguments`对象**

#### 4.2.2 词法环境的抽象伪代码表示
```js
// 全局执行上下文
GlobalExecutionContext={
  LexicalEnvironment: {
    EnvironmentRecord:{
      type:'Object',
      ...//标识符-变量映射关系
    },
    outer：<null>
  }
}

FunctionExecutionContext={
  LexicalEnvironment: {
    EnvironmentRecord: {
      type:'Declarative',
      ... //标识符-变量映射关系
    },
    outer: <Global or outer scope reference>
  }
}
```

#### 4.2.3 词法环境和词法作用域的关联（猜测，辅助理解）
从两者存储的数据来看，**两者的结构是非常相似的，都存储了当前函数中的标识符和变量的映射关系，而且都存储了一个指向外部作用域的指针。但是词法环境中多了存储的函数的arguments对象**

**词法作用域是在编译期生成的，而词法环境是在创建执行上下文的时候生成的，两者结构如此相似，而且在创建执行上下文的时候是没有像编译器一样是扫描代码的，所以词法环境要想获变量的标识符，只能通过当前的词法作用域获取，所以说词法环境是根据词法作用域生成的。**

**但是词法环境并不是获取了词法作用域中所有的变量，而是只存储了使用 `let/const` 定义的变量和函数声明。其他的使用var定义的变量存储在执行上下文的变量环境中。**



### 4.3 变量环境

**变量环境也是一个词法环境，它有着上面词法环境拥有的所有属性。**

在ES6中，变量环境和词法环境唯一的不同在于分工不同：**变量环境只用来存储使用var定义的变量**。

### 4.4 执行上下文的抽象代码结构
```js
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);
```
这段代码的执行上下文如下：
```js
GlobalExecutionContext={
  ThisBound:<Global Object>,
  LexicalEnvironment: {
    EnvironmentRecord:{
      a: < uninitialized >,
      b: < uninitialized >,  //未初始化
      multiply: <function>
    },
    outer:<null>
  },
  VariableEnvironment:{
    EnvironmentRecord:{
      c: undefined  // 已经初始化
    },
    outer: <null>
  }
}

FunctionExecutionContext={
  ThisBound：<Global Object>,
  LexicalEnvironment: {
    EnvironmentRecord:{
      Arguments: {0: 20, 1: 30, length: 2}
    },
    outer:<GlobalLexicalEnvironment>
  },
  VariableEnvironment:{
    EnvironmentRecord:{
      e:undefined,
      f:undefined, //形参变量是使用var定义的
      g:undefined
    },
    outer: <GlobalVariableEnvironment>
  }
}
```
总结一些关键点：
1. **词法环境和变量环境都是根据当前函数所处的词法作用域创建的**，也可以说是将词法作用域分成了两个部分。
2. **在创建执行上下文的时候，代码还没有开始执行，所以执行上下文中存储的都是变量的初始值。当代码开始执行的时候，会执行赋值操作，先执行上下文中找到标识符对应的变量，然后修改变量的值**。
3. **在执行到函数中的块作用域的时候，词法作用域发生变化，会修改当前执行上下文中的词法环境和变量环境。换句话说，执行上下文中的词法环境和变量环境表示的就是当前的词法作用域。**
4. let、const定义的变量，在代码执行之前**没有进行初始化操作，只是声明了这个变量**，所以在初始化之前无法访问（暂时性死区）。
5. var定义的变量，在**代码执行之前经过了声明和初始化的过程（在词法作用域创建的时候，也有可能是创建执行上下文的时候）**，所以在书写上可以先访问后声明，也就是常说的**变量声明提前**。



## 执行上下文和词法作用域之间的关系

前面的文章中，我们有对词法作用域



## 参考文章

1. [理解 JavaScript 中的执行上下文和执行栈](https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-4)
2. [解密 JavaScript 执行上下文](https://juejin.im/post/5cda8c8051882569223af63d)

