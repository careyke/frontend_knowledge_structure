## 闭包是什么？有什么作用？
### 1.闭包的现象
先看一段代码：
```js
function foo(){
  var a=2;
  return function fun(){
    console.log(a);
  }
}
var b = foo();
b(); //2
```  
在代码中，执行完foo()之后，**foo()函数内部的变量应该是会完全销毁的。但是事实上，当fun()函数执行的时候，还是可以拿到foo词法作用域中的a变量**，这种现象就是产生了闭包的现象。

### 2.闭包的定义
在《你不知道的JS》中，对**闭包的定义**是：
```js
当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

闭包指的就是函数对这个被记住的词法作用域的引用
```  
目前来说，这个定义我认为是最标准的，也是最好理解的。

其实**从技术的角度看，所有的函数都会产生闭包**
```js
function foo() { 
  var a = 2;
  function bar() { 
    console.log( a ); // 2
  }
  bar(); 
}
foo();
```  
代码中，**bar函数虽然是在当前作用域就调用了，但是其实bar函数还是会有记住它所在的作用域的，所以理论上也是产生了闭包**。但是这个情况和我们正常的变量查找规则是一样的，所以就不是很好观察。

### 3.闭包和执行上下文（尝试理解，不一定准确）
```js
function a(){
  var x = 1;
  var y = 2;
  function z(){}
  return function b(){
    console.log(x);
    z();
  }
}
function foo(){
  var c = a();
  c();
}
foo();
```  
执行上面的代码，打断点调试：
![closure01.jpg](./images/closure01.jpg)

从调试面板可以看出：
1. **闭包是函数b的执行上下文中词法环境链（作用域链）上的一个部分，也是一个词法环境。**
2. 闭包中**保存的是函数a的执行上下文中词法环境中被函数b引用的变量和函数**。（但是也有可能这个闭包包含了a的词法环境中**所有的**变量，但是浏览器器只打印出引用的部分）
3. 当函数a执行完成之后，a的执行上下文就应该被销毁了。但是**当b函数在创建执行上下文的时候，发现b中有引用a中的变量，于是就会生成一个闭包，用来存储a的执行上下文中词法环境中被b引用的变量，也就是说这些被引用的变量并没有被销毁（是不是也可以说，a的执行上下文并没有被销毁，只是弹出执行栈）**。

闭包在执行上下文中的表现就是：**将一个本来应该要被销毁的执行上下文保留起来（变量状态也会保留，比如变量的值），以闭包的形式存在在另一个函数的执行上下文中，以词法环境链的形式去访问闭包中的变量和函数。**

### 4.闭包的作用和缺陷
#### 4.1 使用闭包可以做到，从函数外面访问或者使用函数的内部变量
```js
function foo(){
  var a = 1;
  return function add(b){
    return a+b;
  }
}
var add = foo();
add(3);  //4
```  
js模块化中大量使用闭包，正是因为闭包有这样的作用。可以**用创建的作用域的形式来隔离每个模块，模块使用闭包的方式暴露出公共的API，用来访问当前模块中的私有内容。**

#### 4.2 闭包的缺陷
**由于闭包使得本来应该销毁的执行上下文暂时没有销毁，一直保存在内存中。所以使用闭包会导致内存消耗比较大，而且使用不小心的话会造成内存泄漏**。

所以在使用闭包的时候一定要小心，注意闭包的销毁时间。









