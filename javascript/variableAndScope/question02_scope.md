## 词法作用域和块作用域
**作用域指的是一套用来管理引擎如何从当前作用域根据标识名获取对应变量的规则。**

在JS中，作用域可以分成两种：
1. 词法作用域
2. 动态作用域

词法作用域可以细分成两个种类：
1. 全局作用域
2. 函数作用域
3. 块作用域

### 1.词法作用域
**词法作用域指的是编译器在对代码做词法分析的时候创建的作用域。**也就是我们平时通过代码分析时所说的作用域。
#### 1.1 遮蔽效应
作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，**直到遇见第一个匹配的标识符为止。**
```js
var a = 1;
function foo(){
  var a = 3;
  console.log(a);
}
foo();
// 3
```  

### 2.动态作用域
词法作用域是代码编译的时候生成的，并不是运行时生成的，所以是**静态的**。

js中提供了两种动态修改词法作用域的方法，但是不推荐使用，介绍一下：
1. 使用eval()修改词法作用域；
2. 使用with关键字生成独立的词法作用域；

#### 2.1 使用eval
eval()的作用是动态执行一段代码，但是同时也会动态的修改当前的词法作用域。
- 在**非严格模式**下，如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就**会对 eval(..) 所处的词法作用域进行修改**。
```js
function foo(a,b){
    eval("var a=5;")
    console.log(a,b);
}
foo(1,2); // 5  2
修改了foo的函数作用域
```  

- 在**严格模式**下，eval()在运行时会有自己的作用域，**不会修改eval所在的词法作用域**。
```js
function foo(a,b){
    "use strict";
    eval("var a=5;console.log(b)");  //eval会产生一个自己的作用域，嵌套在当前作用域里面
    console.log(a,b);
}
foo(1,2); 
// 2
// 1  2
```  

#### 2.2 使用with关键字
with关键字通常被当做重复引用一个对象中多个属性的一种快捷方式。
```js
var obj={
  a:1,
  b:2,
  c:3
}

obj.a=4;
obj.b=5;
obj.c=6;

with(obj){
  a=7,
  b=8,
  c=9
}
console.log(obj);//{a:7,b:8,c:9}
```  
with关键字也可以动态**创建词法作用域**。
```js
function foo(obj){
  with(obj){
    b=6
  }
}
var o1={
  a:1,
  b:2
}
var o2={
  a:3
}
foo(o1);
console.log(o1);  //{a:1, b:6}

foo(o2);
console.log(o2);  //{a:3}

window.b // 6  定义了一个全局的变量
```  
可以看出，**with操作符会将你传递的对象创建出一个新的词法作用域，对象中的属性会被处理成这个词法作用域中的变量标识符。**

所以当o2传进with的时候，创建的词法作用域中没有b这个变量，相当于直接调用b=2，**根据LHS的规则，由于找不到b变量，会在全局作用域创建一个b变量。**

**在严格模式下，with是直接禁用的。**

#### 2.3 动态作用域的性能问题
JavaScript 引擎会在**编译阶段进行数项的性能优化**。其中**有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符**。

但是动态作用域无法确定怎么修改作用域，也就无法在词法分析的时候做出任何优化。所以**在代码中使用动态作用域是会降低性能的**。无论什么时候，都不推荐使用

### 3.函数作用域
函数作用域指的是每一个函数对应的词法作用域。js中具有基于函数的作用域。

#### 3.1立即执行函数（IIFE）
立即执行函数是一个函数表达式，因为IIFE的function关键字是包裹在(..)里面的，所以是一个函数表达式，而不是函数声明。

**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式**

函数声明 VS 函数表达式
- **函数声明的这个函数变量是绑定在当前所在的作用域的。**
- **函数表达式中，这个函数变量是绑定在这个函数作用域之中的。**

所以**立即执行函数是不会污染当前所在的作用域**的。

立即执行函数的作用：**可以使用立即执行函数来创建一个独立的作用域，隐藏一些内部的变量和函数，使外部作用域无法访问到包装内的任何内容。也可以减少污染外层作用域**

```js
var a = 2;
(function add(){
  var a = 3;
  console.log(a);
})()
console.log(a);

//3
//2
```  

### 4.块作用域
**在ES6之前，js中是不存在块作用域的（也不是完全不存在）。只存在全局作用域和函数作用域。**

但是**在ES6开始，js提供的新的变量定义方式let，从而支持了块作用域**。ES6之前只能靠函数作用域去隐藏信息，现在可以通过块作用域去隐藏信息。

js中的**块**是通过**大括号**包裹起来的区域，比如if，while之类的。
- **在es6之前，变量的定义只能通过 var 关键字来完成，块是不会创建作用域的，变量存储在距离它最近的父级作用域中**。
-  **es6开始，可以使用let来定义变量，当一个块中有使用let定义变量的时候，块会创建一个作用域，用来存放这些let（const）定义的变量。**

```js
//var 
var a = 2;
if(a>1){
  var b = 3;
}
console.log(b);  //3

// let 
var a = 2;
if(a>1){
  let b = 3;
}
console.log(b); //ReferenceError: b is not defined
```  

#### 4.1 形成块作用域的方式
1. with关键字
2. try/catch中**catch分句**会创建块作用域
```js
try{
      var a=1;
}catch(e){
      var b = 2;
}
console.log(a); //1
console.log(b); //undefined  说明b存在一个块作用域中
```  

3. let定义变量
```js
for(let i = 0;i<10;i++){
      console.log(i);
}
console.log(i); //ReferenceError: i is not defined
```  

4. const变量


### 5.一个经典的作用域问题
```js
for(var i=0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
// 输出10个10
```  
这段代码之所以输出10个10，就是因为变量i没有自己的块作用域，而是定义在外层作用域中，整个外层作用域共用一个i变量。i的最终值是10，所以输出的是10个10。

#### 5.1 方法一：使用IIFE，利用函数作用域来隔离全局变量
```js
for(var i=0;i<10;i++){
  (function iife(j){
    setTimeout(function(){
    console.log(j);
  },j*1000);
  })(i) 
}
//输出0，1，2，3，4，5，6，7，8，9
```  

#### 5.2 方法二：使用let来定义变量，从而产生块作用域
```js
for(let i=0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
```  
let在for循环中，可以将 i 重新绑定到每一个迭代中，确保使用上一轮迭代结束后的值进行重新赋值。

上面的代码可以类比为：
```js
{
  let i;
  for(i=0;i<10;i++){
    let j = i;
    setTimeout(function(){
      console.log(j);
    },j*1000);
  }
}
每次迭代的时候都是重新绑定
```  

#### 5.3 可以使用setTimeout的第三个参数
```js
for(var i=0;i<10;i++){
  setTimeout(function(j){
    console.log(j);
  },i*1000,i);
}
```  
这个方法没有什么通用性，只是但对于setTimeout而言的。















