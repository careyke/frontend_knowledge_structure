# 作用域和作用域链

**作用域指的是在程序中定于变量的区域，该位置决定了变量的生命周期。通俗的理解，作用域就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**

按照作用域创建的时机来划分，可以分成：
1. 词法作用域
2. 动态作用域



按照作用域的种类来划分，可以分成：
1. 全局作用域
2. 函数作用域
3. 块作用域



## 1. 按照作用域创建的时机来划分

### 1.1 词法作用域
**词法作用域指的是在编译期根据代码中函数声明的位置来划分的作用域。属于静态作用域**。函数的作用域在函数定义的时候就已经确定了，和函数调用的位置无关。

JS采用的就是词法作用域。

一般情况下，词法作用域在编译期就已经创建完成，并且其内部定义的变量和函数数量在运行时是不可修改的，作用域树也是稳定不变的。

> 这里将程序的所有作用域类比成一个树形结构。

但是凡事都有例外，js中有两种方式可以在运行时动态修改词法作用域或者作用域树的结构。

1. 使用`eval()`修改词法作用域或者创建独立作用域
2. 使用`with`关键字创建独立的块级作用域



#### 1.1.1 使用eval

eval()的作用是动态执行一段代码

- 在**非严格模式**下，如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就**会对 eval(..) 所处的词法作用域进行修改**。

```js
function foo(a,b){
    eval("var a=5;")
    console.log(a,b);
}
foo(1,2); // 5  2
// 修改了foo的函数作用域
```

- 在**严格模式**下，eval()在运行时会创建独立的作用域，**不会修改eval所在的词法作用域**。

  > eval是创建一个新的执行上下文，包含词法环境和变量环境

```js
function foo(a,b){
    "use strict";
    eval("var a=5;console.log(b)");  //eval会产生一个自己的作用域，嵌套在当前作用域里面
    console.log(a,b);
}
foo(1,2); 
// 2
// 1  2
```



#### 1.1.2 使用with关键字

with关键字通常被当做重复引用一个对象中多个属性的一种快捷方式。

```js
var obj={
  a:1,
  b:2,
  c:3
}

obj.a=4;
obj.b=5;
obj.c=6;

with(obj){
  a=7,
  b=8,
  c=9
}
console.log(obj);//{a:7,b:8,c:9}
```

with关键字也可以动态**创建作用域**。

```js
function foo(obj){
  with(obj){
    b=6
  }
}
var o1={
  a:1,
  b:2
}
var o2={
  a:3
}
foo(o1);
console.log(o1);  //{a:1, b:6}

foo(o2);
console.log(o2);  //{a:3}

window.b // 6  定义了一个全局的变量
```

可以看出，**with操作符会根据你传递的对象创建出一个新的块级作用域，对象中的属性会被处理成这个块级作用域中的变量标识符。**

> 这里with其实是动态在当前执行上下文中创建一个词法环境，在下一节会详细讲解这个。

所以当o2传进with的时候，创建的块级作用域中没有b这个变量，相当于直接调用b=2，**根据LHS的规则，由于找不到b变量，会在全局作用域创建一个b变量。**

**在严格模式下，with是直接禁用的。**



#### 1.1.3 动态创建作用域的性能问题

`JavaScript`引擎会在**编译阶段进行数项的性能优化**。其中**有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符**。

但是动态作用域无法确定怎么修改作用域，也就无法在词法分析的时候做出任何优化。所以**在代码中使用动态作用域是会降低性能的**。除非是在特殊的情况下，否则都不推荐使用



### 1.2 动态作用域

**与词法作用域相反，动态作用域中函数的作用域和作用域链在运行时才能确定，和函数的调用位置密切相关。**

JS是静态作用域语言，所以并不存在动态作用域。上面介绍的`eval和with`并不是动态作用域的体现，它们只是动态创建或修改作用域，但是并不能修改函数的作用域链。

看一个经典的例子：

```js
var a = 1;

function foo(){
  console.log(a);
}

function bar(){
  var a = 2;
  foo();
}

bar();
// 输出：1
```

结合上面例子来分析：

- 如果JS采用静态作用域，那么执行到foo时，发现foo中没有a变量，会向上层作用域查找，会查找到全局作用域。所以输出结果是`1`

- 如果JS采用动态作用域，那么执行到foo时，发现foo中没有a变量，就会在bar函数作用域中查找，所以输出的是`2`

从执行的结果来看，JS采用的是静态作用域，也就是词法作用域。



## 2. 按照作用域种类来划分

### 2.1 全局作用域

每个JS程序的最顶层对应一个全局作用域，其中定义的变量和函数全局都可以访问。当程序销毁时，对应的变量才会销毁。



### 2.2 函数作用域

函数作用域指的是每一个函数对应的词法作用域。函数内部定义变量和函数只能在函数内部访问，函数执行完成之后，内部定义的变量也会被销毁。

#### 2.2.1 立即执行函数（IIFE）
立即执行函数是一个函数表达式，因为IIFE的function关键字是包裹在(..)里面的，所以是一个函数表达式，而不是函数声明。

**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式**

函数声明 VS 函数表达式
- **函数声明的这个函数变量是绑定在当前所在的作用域的。**
- **函数表达式中，这个函数变量是绑定在这个函数作用域之中的。**

所以**立即执行函数是不会污染当前所在的作用域**的。

立即执行函数的作用：**可以使用立即执行函数来创建一个独立的作用域，隐藏一些内部的变量和函数，使外部作用域无法访问到包装内的任何内容。也可以减少污染外层作用域**

```js
var a = 2;
(function add(){
  var a = 3;
  console.log(a);
})()
console.log(a);
add();

//3
//2
//Uncaught ReferenceError:add is not defined
```



### 2.3 块作用域

**在ES6之前，js中是不存在块作用域的（也不是完全不存在）。只存在全局作用域和函数作用域。**

但是**在ES6开始，js提供的新的变量定义方式let，从而支持了块作用域**。ES6之前只能靠函数作用域去隐藏信息，现在可以通过块作用域去隐藏信息。

js中的**块**是通过**大括号**包裹起来的区域，比如if，while之类的。
- **在es6之前，变量的定义只能通过 var 关键字来完成，块是不会创建作用域的，变量存储在距离它最近的父级作用域中**。
-  **es6开始，可以使用let来定义变量，当一个块中有使用let定义变量的时候，块会创建一个作用域，用来存放这些let（const）定义的变量。**

```js
//var 
var a = 2;
if(a>1){
  var b = 3;
}
console.log(b);  //3

// let 
var a = 2;
if(a>1){
  let b = 3;
}
console.log(b); //ReferenceError: b is not defined
```

#### 2.3.1 形成块作用域的方式
1. with关键字
2. try/catch中**catch分句**会创建块作用域
```js
try{
  		var a = 1;
      throw 'err';
}catch(e){
      var b = 2
}
console.log(a); //1
console.log(b); //2
console.log(e); //Uncaught ReferenceError: e is not defined
```

> 前面这两种形成块级作用域的方式现在基本不会用到，这里只是单纯列举出来，有个印象就行

3. let定义变量
```js
for(let i = 0;i<10;i++){
      console.log(i);
}
console.log(i); //ReferenceError: i is not defined
```

4. const变量




### 2.4 一个经典的作用域问题
```js
for(var i=0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
// 输出10个10
```
这段代码之所以输出10个10，就是因为变量i没有自己的块作用域，而是定义在外层作用域中，整个外层作用域共用一个i变量。i的最终值是10，所以输出的是10个10。

#### 5.1 方法一：使用IIFE，利用函数作用域来隔离全局变量
```js
for(var i=0;i<10;i++){
  (function iife(j){
    setTimeout(function(){
    console.log(j);
  },j*1000);
  })(i) 
}
//输出0，1，2，3，4，5，6，7，8，9
```

#### 5.2 方法二：使用let来定义变量，从而产生块作用域
```js
for(let i=0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
```
let在for循环中，可以将 i 重新绑定到每一个迭代中，确保使用上一轮迭代结束后的值进行重新赋值。

上面的代码可以类比为：
```js
{
  let i;
  for(i=0;i<10;i++){
    let j = i;
    setTimeout(function(){
      console.log(j);
    },j*1000);
  }
}
每次迭代的时候都是重新绑定
```

相当于每次执行块内部的代码时，对应块级作用域中临时变量`i`的值都不一样。有点类似于闭包。

#### 5.3 可以使用setTimeout的第三个参数

```js
for(var i=0;i<10;i++){
  setTimeout(function(j){
    console.log(j);
  },i*1000,i);
}
```
这个方法没有什么通用性，只是对于setTimeout而言的。



## 3. 作用域链

前面我们提到过，整个JS程序的词法作用域可以类比成一个树。每个作用域都有一条链路可以查找到最顶层的全局作用域，这样的一条查找链称为作用域链。

代码执行的时候，会**根据作用域链从下到上来遍历链路中的每个词法作用域，查找需要使用的变量或者函数**。

作用域链中每个节点都是词法作用域，每个词法作用域在编译期创建的时候都包含一个指向外层作用域的指针，由此形成作用域链。所以作用域链也是静态的，在编译期创建。



## 4. 总结

**词法作用域和作用域链都是抽象的概念，用来描述代码的执行规则。实际上并不存在词法作用域这个具体对象，词法作用域更像是一个顶层的抽象概念，规则的具体实现由执行上下文来实现**。

下一节会详细分析执行上下文。

> 笔者自己的观点

