# 作用域和作用域链

**作用域指的是在程序中定于变量的区域，该位置决定了变量的生命周期。通俗的理解，作用域就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**

按照作用域创建的时机来划分，可以分成：
1. 词法作用域
2. 动态作用域



按照作用域的种类来划分，可以分成：
1. 全局作用域
2. 函数作用域
3. 块作用域



## 1. 按照作用域创建的时机来划分

### 1.1 词法作用域
**词法作用域指的是在编译期根据代码中函数声明的位置来划分的作用域。属于静态作用域**。函数的作用域在函数定义的时候就已经确定了，和函数调用的位置无关。

JS采用的就是词法作用域。

一般情况下，词法作用域在编译期就已经创建完成，并且其内部定义的变量和函数数量在运行时是不可修改的，作用域树也是稳定不变的。

> 这里将程序的所有作用域类比成一个树形结构。

但是凡事都有例外，js中有两种方式可以在运行时动态修改词法作用域。



### 1.2 动态作用域

词法作用域是代码编译的时候生成的，并不是运行时生成的，所以是**静态的**。

js中提供了两种动态修改词法作用域的方法，但是不推荐使用，介绍一下：
1. 使用eval()修改词法作用域；
2. 使用with关键字生成独立的词法作用域；

#### 2.1 使用eval
eval()的作用是动态执行一段代码，但是同时也会动态的修改当前的词法作用域。
- 在**非严格模式**下，如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就**会对 eval(..) 所处的词法作用域进行修改**。
```js
function foo(a,b){
    eval("var a=5;")
    console.log(a,b);
}
foo(1,2); // 5  2
修改了foo的函数作用域
```

- 在**严格模式**下，eval()在运行时会有自己的作用域，**不会修改eval所在的词法作用域**。
```js
function foo(a,b){
    "use strict";
    eval("var a=5;console.log(b)");  //eval会产生一个自己的作用域，嵌套在当前作用域里面
    console.log(a,b);
}
foo(1,2); 
// 2
// 1  2
```

#### 2.2 使用with关键字
with关键字通常被当做重复引用一个对象中多个属性的一种快捷方式。
```js
var obj={
  a:1,
  b:2,
  c:3
}

obj.a=4;
obj.b=5;
obj.c=6;

with(obj){
  a=7,
  b=8,
  c=9
}
console.log(obj);//{a:7,b:8,c:9}
```
with关键字也可以动态**创建词法作用域**。
```js
function foo(obj){
  with(obj){
    b=6
  }
}
var o1={
  a:1,
  b:2
}
var o2={
  a:3
}
foo(o1);
console.log(o1);  //{a:1, b:6}

foo(o2);
console.log(o2);  //{a:3}

window.b // 6  定义了一个全局的变量
```
可以看出，**with操作符会根据你传递的对象创建出一个新的词法作用域，对象中的属性会被处理成这个词法作用域中的变量标识符。**

所以当o2传进with的时候，创建的词法作用域中没有b这个变量，相当于直接调用b=2，**根据LHS的规则，由于找不到b变量，会在全局作用域创建一个b变量。**

**在严格模式下，with是直接禁用的。**



#### 2.3 动态作用域的性能问题
*JavaScript* 引擎会在**编译阶段进行数项的性能优化**。其中**有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符**。

但是动态作用域无法确定怎么修改作用域，也就无法在词法分析的时候做出任何优化。所以**在代码中使用动态作用域是会降低性能的**。除非是在特殊的情况下，否则都不推荐使用



### 3.函数作用域
函数作用域指的是每一个函数对应的词法作用域。js中具有基于函数的作用域。

#### 3.1立即执行函数（IIFE）
立即执行函数是一个函数表达式，因为IIFE的function关键字是包裹在(..)里面的，所以是一个函数表达式，而不是函数声明。

**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式**

函数声明 VS 函数表达式
- **函数声明的这个函数变量是绑定在当前所在的作用域的。**
- **函数表达式中，这个函数变量是绑定在这个函数作用域之中的。**

所以**立即执行函数是不会污染当前所在的作用域**的。

立即执行函数的作用：**可以使用立即执行函数来创建一个独立的作用域，隐藏一些内部的变量和函数，使外部作用域无法访问到包装内的任何内容。也可以减少污染外层作用域**

```js
var a = 2;
(function add(){
  var a = 3;
  console.log(a);
})()
console.log(a);
add();

//3
//2
//Uncaught ReferenceError:add is not defined
```

### 4.块作用域
**在ES6之前，js中是不存在块作用域的（也不是完全不存在）。只存在全局作用域和函数作用域。**

但是**在ES6开始，js提供的新的变量定义方式let，从而支持了块作用域**。ES6之前只能靠函数作用域去隐藏信息，现在可以通过块作用域去隐藏信息。

js中的**块**是通过**大括号**包裹起来的区域，比如if，while之类的。
- **在es6之前，变量的定义只能通过 var 关键字来完成，块是不会创建作用域的，变量存储在距离它最近的父级作用域中**。
-  **es6开始，可以使用let来定义变量，当一个块中有使用let定义变量的时候，块会创建一个作用域，用来存放这些let（const）定义的变量。**

```js
//var 
var a = 2;
if(a>1){
  var b = 3;
}
console.log(b);  //3

// let 
var a = 2;
if(a>1){
  let b = 3;
}
console.log(b); //ReferenceError: b is not defined
```

#### 4.1 形成块作用域的方式
1. with关键字
2. try/catch中**catch分句**会创建块作用域
```js
try{
  		var a = 1;
      throw 'err';
}catch(e){
      var b = 2
}
console.log(a); //1
console.log(b); //2
console.log(e); //Uncaught ReferenceError: e is not defined
```

> 前面这两种形成块级作用域的方式现在基本不会用到，这里只是单纯列举出来，有个印象就行

3. let定义变量
```js
for(let i = 0;i<10;i++){
      console.log(i);
}
console.log(i); //ReferenceError: i is not defined
```

4. const变量




### 5.一个经典的作用域问题
```js
for(var i=0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
// 输出10个10
```
这段代码之所以输出10个10，就是因为变量i没有自己的块作用域，而是定义在外层作用域中，整个外层作用域共用一个i变量。i的最终值是10，所以输出的是10个10。

#### 5.1 方法一：使用IIFE，利用函数作用域来隔离全局变量
```js
for(var i=0;i<10;i++){
  (function iife(j){
    setTimeout(function(){
    console.log(j);
  },j*1000);
  })(i) 
}
//输出0，1，2，3，4，5，6，7，8，9
```

#### 5.2 方法二：使用let来定义变量，从而产生块作用域
```js
for(let i=0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },i*1000);
}
```
let在for循环中，可以将 i 重新绑定到每一个迭代中，确保使用上一轮迭代结束后的值进行重新赋值。

上面的代码可以类比为：
```js
{
  let i;
  for(i=0;i<10;i++){
    let j = i;
    setTimeout(function(){
      console.log(j);
    },j*1000);
  }
}
每次迭代的时候都是重新绑定
```

相当于每次执行块内部的代码时，对应块级作用域中临时变量`i`的值都不一样。有点类似于闭包。

#### 5.3 可以使用setTimeout的第三个参数

```js
for(var i=0;i<10;i++){
  setTimeout(function(j){
    console.log(j);
  },i*1000,i);
}
```
这个方法没有什么通用性，只是对于setTimeout而言的。















