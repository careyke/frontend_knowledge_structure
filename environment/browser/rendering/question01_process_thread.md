# 浏览器中的进程和线程

## 1. 进程和线程

先看一个例子来理解一下进程与线程之间的区别：

```js
- 进程是一个工厂，工厂有它的独立资源

- 工厂之间相互独立

- 线程是工厂中的工人，多个工人协作完成任务

- 工厂内有一个或多个工人

- 工人之间共享空间
```

继续完善整个概念

```js
- 工厂的资源 -> 系统分配的内存（独立的一块内存）

- 工厂之间的相互独立 -> 进程之间相互独立

- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务

- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成

- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
```

通过上面的描述可知：

1. **进程是cpu资源分配的最小单位，也就是能够拥有资源和独立运行的最小单位**
2. **线程是cpu调度的最小单位，线程是运行在某个进程环境中的，一个进程中可以有多个线程**
3. 不同进程之间可以通信，但是代价比较大



## 2. 浏览器是多进程的

浏览器是一个多进程的环境，它主要包含以下进程：

1. Browser进程：浏览器的主进程，负责整体上协调和控制整个浏览器环境
   - 负责浏览器界面显示，与用户交互。如前进，后退等
   - 负责各个页面的管理，创建和销毁其他进程
   - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
   - 网络资源的管理，下载等

2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU进程：最多一个，用于3D绘制等
4. **浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）**：默认每个浏览器页签就会有一个Renderer进程，互不影响。主要负责页面的渲染，脚本执行和事件处理等

**一般我们主要关注的是浏览器的渲染进程，浏览器中每打开一个页签就相当于是新创建一个渲染进程。**

**注意**：每个页签对应一个进程并不是绝对成立的，浏览器内部有自己的优化机制，有时会将多个进程合并成一个进程。



## 3. 浏览器渲染进程是多线程的

我们常说js是一个单线程的语言，但是在很多文章中会说到浏览器内核是单线程的，这个是绝对错误的。

浏览器的渲染进程是多线程的，以下就是渲染进程中的一些常用线程。

1. GUI渲染线程
   - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
   - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
2. JS引擎线程
   - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
   - S引擎线程负责解析Javascript脚本，运行代码。
   - JS引擎一直等待着**任务队列**中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
   - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. 事件触发线程
   - 内部保存**事件队列（任务队列）**，用来控制事件循环
   - 当JS引擎执行代码块如setTimeOut时，会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
   - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4. 定时触发器线程
   - 也就是`setTimeout和setInterval`所在的线程
   - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   - 而是通过定时触发线程来计时并触发计时完毕的操作，将对应的回调函数添加到**任务队列**中
   - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms
5. 异步http请求线程
   - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入**事件队列**中。再由JavaScript引擎执行。

在了解了浏览器渲染进程的多个线程之后，下面来解答一些常见的问题。

### 3.1 为什么要将js引擎线程和GUI渲染线程做成互斥的？

因为js中是可以用来操作DOM的，如果在js操作DOM的过程中，UI线程同时也触发，那么很有可能会导致**UI渲染出来的结果和预期结果不一致的情况，而且也会导致UI线程渲染很多多余的中间状态**。

所以才会将js引擎线程和GUI渲染线程设置成互斥的



## 参考文章

1. [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-16)

   