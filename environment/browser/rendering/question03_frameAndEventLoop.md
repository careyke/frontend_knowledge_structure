# 浏览器帧和EventLoop

## 1. 浏览器帧（FPS）

浏览器帧数表示的是 1S 内浏览器页面渲染的次数。一般对于人类的视觉来说，动画运行的帧数达到60帧时，会感觉动画是非常流畅的，也就是每帧的运行时间大约是16.7ms。但是当帧数小于60帧的时候，视觉上会感觉动画有卡顿的感觉，也就是俗称的”**掉帧**“。



## 2. EventLoop的工作流程

参考`javascript/async`章节中对于eventLoop的描述。[链接](https://github.com/careyke/frontend_knowledge_structure/blob/master/javascript/async/question01_eventLoop.md) eventLoop中每个tick的大致流程如下：

1. 从宏任务队列中取出一个宏任务（Task），然后放入执行栈中开始执行同步代码。
2. 宏任务执行完成之后，执行此时微任务队列中所有的微任务(Job)
3. 当所有微任务执行完成之后，判断是否需要执行一次UI渲染，如果需要则由渲染线程执行一次UI渲染，如果不需要则跳过
4. 检查是否存在 Web worker 任务，如果有，则对其进行处理
5. 当前tick完成，回到步骤1，开始下一个tick，直到宏任务队列被清空

可以看出，**eventLoop的每个tick中都有可能伴随一次UI渲染，会导致页面生成一个新的快照，产生新的一帧。也即是说在某种极端的情况下，eventLoop的每一个tick就对应浏览器的每一帧。**

然而实际的情况并不是如此，eventLoop中的很多tick只是执行单纯的js任务，没有涉及到页面UI的改变，这时可以在浏览器的`performance` 工具中看到，当前帧中包含了多个Task，而且当前帧的时间远远超过16.7ms。当然这种情况是正常的，因为每个tick中都会有一次判断是否需要更新UI的操作，如果中间某个tick需要更新，则会在这tick中产生一个新的快照，更新一帧。如果不需要更新，自然就会执行到下一个tick，当前帧的时间就会包含多个tick。

所以可以认为：**每一帧的时间里面都包含一个或多个tick的执行，然后再进行UI渲染产生新的页面快照。**



## 3. 浏览器帧的完整工作流程（*）

当用户与页面进行交互的时候，垂直同步信号`Vsync`触发，开启新的一帧。

1. 开启 eventLoop 中一个新的tick，执行对应事件的回调函数，也就是执行一个Task。（**实际上事件的回调函数也就在对应事件触发的时候push到Task队列中**）

2. 检查微任务队列，执行并清空微任务队列
3. 进入更新渲染阶段，判断是否需要渲染。这里有一个 `rendering opportunity` 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）
   - **浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧**
   - **如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低**
   - 如果满足以下条件，也会跳过渲染：
     - 浏览器判断更新渲染不会带来视觉上的改变
     - `map of animation frame callbacks` 为空，也就是帧动画回调为空，可以通过 `requestAnimationFrame` 来请求帧动画。

4. 如果第三步判断不需要进行UI渲染，那么后面的步骤也不需要执行
5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行 `resize` 回调函数。
6. 对于需要渲染的文档，如果页面发生了滚动，执行 `scroll` 的回调函数。
7. 对于需要渲染的文档，执行帧动画回调，也就是 **`requestAnimationFrame`** 的回调。
8. 对于需要渲染的文档， 执行 `IntersectionObserver` 的回调。
9. 对于需要渲染的文档，**重新渲染**绘制用户界面。
10. 判断当前帧是否还有空余的时间，如果有的话执行**`requestIdleCallback`** 的回调函数

对于 `resize` 和 `scroll` 这种需要实时交互的事件，并不是在对应的第5步和第6步才去执行页面的滚动和缩放，这样的话页面会产生卡顿。浏览器会立即执行页面的滚动和缩放，同时保存一个`event targte` 对象，然后在对应的步骤执行对应的回调函数。也就是说，**浏览器对于 `resize`和`scroll` 的回调函数本身就会有一个节流的效果。**



## 4. 帧与优化策略

在构建web应用的时候，要尽量保持页面动画到达60帧，这样用户才不会觉得卡顿。然后在前面的分析中可以得知，每帧都有`JS线程`和`渲染线程`的参与，而这两个线程是互斥的，所以影响帧数的因素大致可以分成两类：

1. 在当前tick中，js代码逻辑比较复杂，js代码执行时间过长，导致UI渲染线程迟迟不能执行。
2. 在当前tick中导致页面变化比较大，重排和重绘的元素过多，UI渲染时间太长。

对应的优化的策略：

1. **将复杂的JS任务分时间片处理，分在多个tick中处理。如果在当前任务处理的时候，需要更新页面，就可以及时打断当前任务的执行，更新完页面之后再接着执行之前的任务**。React中的Fiber架构就是利用这种思路来调度更新任务的。
2. **在更新页面的时候，尽量减少页面的重排和重绘**。



## 5. 参考链接

1. [深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系](https://mp.weixin.qq.com/s/l9pGe7-xY08DeaFMnk0xuA)
2. [[译] 浏览器帧原理剖析](https://juejin.cn/post/6844903808762380296)

