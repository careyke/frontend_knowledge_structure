# 结合React源码谈谈虚拟列表的实现和优化思路

在实际的开发中，我们常常会遇到大数据渲染卡顿的问题。这个问题需要从以下两个方面来优化：

1. 渲染层：采用**虚拟列表**的方式来渲染，也就是每次只渲染**可视区域**和**buffer区域**的节点，大量减少渲染的节点数量，优化的效果十分明显。
2. 网络层：数据分页请求

综合上面两个方面的优化，通常会有以下两种方案。

1. **滚动加载（懒加载）**：滚动最后一个节点的时候会卡住，直到下一页的数据回来之后才能继续滚动。
2. **无限滚动**：初始就为所有的节点空出位置，可以直接滚动到最后一条数据，在滚动的过程中根据索引来判断请求哪一页的数据。

在实现上来说，滚动加载实现起来相对简单一些。但是从体验来说无限滚动更加流畅。所以笔者更加倾向于使用无限滚动的方案。

无论是滚动加载还是无限滚动，无非是获取数据的时机不一样。优化的核心还是需要虚拟列表的支撑，下面我们就来讲解一下虚拟列表的实现思路和优化方案。



## 1. 虚拟列表的实现思路

虚拟列表实现的**关键目标**是：

1. 获取当前需要渲染节点片段的头尾索引
2. 计算每个渲染节点的位置

要达成上面的关键目标，我们需要有以下**前提条件**：

1. 可视窗口的尺寸
2. 节点的总数量
3. 节点的尺寸
4. 滚动的距离
5. buffer的个数

通过上面的前提条件，我们就可以计算出前面关键目标中所需要的数据。



其中**节点的尺寸有稳定和不稳定**两种，可以将虚拟列表分成**稳定的虚拟列表**和**不稳定的虚拟列表**。

1. 稳定的虚拟列表计算的过程比较简单，可以参考代码[**VirtualizedComponent.tsx**](https://github.com/careyke/react-virtualized-core/blob/main/src/core/VirtualizedComponent.tsx)
2. 不稳定的虚拟列表计算的过程比较复杂，笔者参考了 [`react-window`](https://github.com/bvaughn/react-window) 中的实现，可以参考代码[**VariableSizeVirtualizedComponent.tsx**](https://github.com/careyke/react-virtualized-core/blob/main/src/core/VariableSizeVirtualizedComponent.tsx)

具体的实现步骤笔者在这里就不详细描述了，大家可以参考`react-window`的源码或者这篇文章：[再谈前端虚拟列表的实现](https://zhuanlan.zhihu.com/p/34585166)，作者写得非常好。

这里笔者主要是想详细讲解一下在`react-window`之上的进一步的优化方案。



## 2. 虚拟列表的优化方案 - key值优化

在算法层面，`react-window`中的实现已经优化到了极致。笔者优化的角度是**对于`key`值的优化**。

在React中，`key`对于列表中的元素来说非常重要，其决定了对应的真实DOM节点是创建、销毁、更新还是移动，对于性能的影响比较大。

在`react-window`中，每个节点默认的`key`是对应的索引。那么在滚动的过程中，必然会有真实DOM节点的新建和销毁操作。在比较复杂的列表或者性能一般的机器中，快速滚动的时候**白屏**还是比较严重的。

### 2.1 key值优化

`key`值优化的思路就是 **新增的节点尽可能的重用之前销毁节点的key值，其他节点的key值保持不变**。这样就可以尽量减少真实`DOM`节点的销毁和重建，取而代之的是代价更小的更新。

要实现key值优化的前提条件就是**列表子节点需要使用绝对定位，将节点的索引顺序和真实的渲染位置顺序区分开来。**

